library(sp)
library(sf)
library(raster)
library(randomForest)
library(rgeos)
library(doParallel)
library(plyr)
library(tidyverse)
# Constants
classProperty <- 'arbuscular_mycorrhizal_richness'
df <- read.csv('data/arbuscular_mycorrhizal_richness_training_data.csv')
# Convert DataFrame to SpatialPointsDataFrame
coordinates(df) <- c('Pixel_Long', 'Pixel_Lat')
proj4string(df) <- CRS('+init=epsg:4326')
# Variables to include in the model
covariateList <- c(
'CGIAR_PET',
'CHELSA_BIO_Annual_Mean_Temperature',
'CHELSA_BIO_Annual_Precipitation',
'CHELSA_BIO_Max_Temperature_of_Warmest_Month',
'CHELSA_BIO_Precipitation_Seasonality',
'ConsensusLandCover_Human_Development_Percentage',
'EarthEnvTexture_CoOfVar_EVI',
'EarthEnvTexture_Correlation_EVI',
'EarthEnvTexture_Homogeneity_EVI',
'EarthEnvTopoMed_AspectCosine',
'EarthEnvTopoMed_AspectSine',
'EarthEnvTopoMed_Elevation',
'EarthEnvTopoMed_Slope',
'EarthEnvTopoMed_TopoPositionIndex',
'EsaCci_BurntAreasProbability',
'GHS_Population_Density',
'GlobBiomass_AboveGroundBiomass',
'MODIS_NPP',
'SG_Depth_to_bedrock',
'SG_Sand_Content_005cm',
'SG_SOC_Content_005cm',
'SG_Soil_pH_H2O_005cm'
)
project_vars <- c(
'sequencing_platform454Roche',
'sequencing_platformIllumina',
'sample_typerhizosphere_soil',
'sample_typesoil',
'sample_typetopsoil',
'primersAML1_AML2_then_AMV4_5NF_AMDGR',
'primersAML1_AML2_then_NS31_AM1',
'primersAML1_AML2_then_nu_SSU_0595_5__nu_SSU_0948_3_',
'primersAMV4_5F_AMDGR',
'primersAMV4_5NF_AMDGR',
'primersGeoA2_AML2_then_NS31_AMDGR',
'primersGeoA2_NS4_then_NS31_AML2',
'primersGlomerWT0_Glomer1536_then_NS31_AM1A_and_GlomerWT0_Glomer1536_then_NS31_AM1B',
'primersGlomerWT0_Glomer1536_then_NS31_AM1A__GlomerWT0_Glomer1536_then_NS31_AM1B',
'primersNS1_NS4_then_AML1_AML2',
'primersNS1_NS4_then_AMV4_5NF_AMDGR',
'primersNS1_NS4_then_NS31_AM1',
'primersNS1_NS41_then_AML1_AML2',
'primersNS31_AM1',
'primersNS31_AML2',
'primersWANDA_AML2'
)
# Create final list of covariates
covariateList <- c(covariateList, project_vars)
run_spatial_loo_cv <- function(buffer_size, rep) {
# Project to a meter-based CRS
df_proj <- spTransform(df, CRS('+init=epsg:3857'))
# Create buffer in meters
df_proj$geometry_buffer <- rgeos::gBuffer(df_proj, width = buffer_size, byid = TRUE)
# Initialize classifier
classifier <- randomForest(mtry = 2, ntree = 500)
# Read in the grid search results from GEE
grid_search_results <- read.csv('output/20230315_arbuscular_mycorrhizal_richness_grid_search_results_spatialCV.csv')
VPS <- as.numeric(str_extract(grid_search_results[rep, "cName"], "VPS\\d+"))
LP <- as.numeric(str_extract(grid_search_results[rep, "cName"], "LP\\d+"))
MN <- as.numeric(str_extract(grid_search_results[rep, "cName"], "MN\\d+"))
if (is.na(MN)) {
MN <- NULL
}
# Set hyperparameters
classifier <- randomForest(mtry = VPS, ntree = 25, maxnodes = MN, nodesize = LP, replace = FALSE, sampsize = floor(0.632 * nrow(df_proj)))
# Prepare data
set.seed(rep)
sampled_df_proj <- df_proj[sample(nrow(df_proj), 10000, replace = FALSE),]
X <- sampled_df_proj[, covariateList, drop = FALSE]
y <- sampled_df_proj[, classProperty, drop = FALSE]
# Create LeaveOneOut folds after defining y
loo <- createFolds(y, k = nrow(df_proj), list = TRUE, returnTrain = FALSE)
predictions <- c()
# Perform spatial Leave-One-Out Cross-Validation
for (i in 1:length(loo)) {
test_point <- df_proj$geometry_buffer[loo[[i]]$indexOut]
train_points <- df_proj[!gIntersects(test_point, df_proj, byid = TRUE),]
if (nrow(train_points) > 0) {
classifier <- train(y[train_points] ~ ., data = X[train_points,], method = "rf", mtry = VPS, ntree = 25, maxnodes = MN, nodesize = LP, replace = FALSE, sampsize = floor(0.632 * nrow(train_points)))
predictions <- c(predictions, predict(classifier, X[-train_points,]))
} else {
predictions <- c(predictions, NA)
}
}
# Calculate R-squared value
r2 <- R2(predictions, y)
output <- data.frame(r2 = r2, rep = rep, buffer_size = buffer_size)
return(output)
}
buffer_sizes <- c(1000, 2500, 5000, 10000, 50000, 100000, 250000, 500000, 750000, 1000000)
reps <- seq(0, 9)
# Define the list of buffer sizes to use
buffer_sizes <- c(10000, 250000, 1000000)
reps <- seq(0, 2)
# Use parallel processing
registerDoParallel(cores = 7)
results <- foreach(buffer = buffer_sizes, rep = reps, .combine = rbind) %dopar% run_spatial_loo_cv(buffer, rep)
# Calculate R-squared value
r2 <- R2(predictions, y)
run_spatial_loo_cv <- function(buffer_size, rep) {
# Project to a meter-based CRS
df_proj <- spTransform(df, CRS('+init=epsg:3857'))
# Create buffer in meters
df_proj$geometry_buffer <- rgeos::gBuffer(df_proj, width = buffer_size, byid = TRUE)
# Initialize classifier
classifier <- randomForest(mtry = 2, ntree = 500)
# Read in the grid search results from GEE
grid_search_results <- read.csv('output/20230315_arbuscular_mycorrhizal_richness_grid_search_results_spatialCV.csv')
VPS <- as.numeric(str_extract(grid_search_results[rep, "cName"], "VPS\\d+"))
LP <- as.numeric(str_extract(grid_search_results[rep, "cName"], "LP\\d+"))
MN <- as.numeric(str_extract(grid_search_results[rep, "cName"], "MN\\d+"))
if (is.na(MN)) {
MN <- NULL
}
# Set hyperparameters
classifier <- randomForest(mtry = VPS, ntree = 25, maxnodes = MN, nodesize = LP, replace = FALSE, sampsize = floor(0.632 * nrow(df_proj)))
# Prepare data
set.seed(rep)
sampled_df_proj <- df_proj[sample(nrow(df_proj), 10000, replace = FALSE),]
X <- sampled_df_proj[, covariateList, drop = FALSE]
y <- sampled_df_proj[, classProperty, drop = FALSE]
# Create LeaveOneOut folds after defining y
loo <- createFolds(y, k = nrow(df_proj), list = TRUE, returnTrain = FALSE)
predictions <- c()
# Perform spatial Leave-One-Out Cross-Validation
for (i in 1:length(loo)) {
test_point <- df_proj$geometry_buffer[loo[[i]]$indexOut]
train_points <- df_proj[!gIntersects(test_point, df_proj, byid = TRUE),]
if (nrow(train_points) > 0) {
classifier <- train(x = y[train_points] ~ ., data = X[train_points,], method = "rf", mtry = VPS, ntree = 25, maxnodes = MN, nodesize = LP, replace = FALSE, sampsize = floor(0.632 * nrow(train_points)))
predictions <- c(predictions, predict(classifier, X[-train_points,]))
} else {
predictions <- c(predictions, NA)
}
}
# Calculate R-squared value
r2 <- R2(predictions, y)
output <- data.frame(r2 = r2, rep = rep, buffer_size = buffer_size)
return(output)
}
buffer_sizes <- c(1000, 2500, 5000, 10000, 50000, 100000, 250000, 500000, 750000, 1000000)
reps <- seq(0, 9)
# Define the list of buffer sizes to use
buffer_sizes <- c(10000, 250000, 1000000)
reps <- seq(0, 2)
# Use parallel processing
registerDoParallel(cores = 7)
results <- foreach(buffer = buffer_sizes, rep = reps, .combine = rbind) %dopar% run_spatial_loo_cv(buffer, rep)
buffer_size = 1000
rep = 1
# Project to a meter-based CRS
df_proj <- spTransform(df, CRS('+init=epsg:3857'))
# Create buffer in meters
df_proj$geometry_buffer <- rgeos::gBuffer(df_proj, width = buffer_size, byid = TRUE)
# Initialize classifier
classifier <- randomForest(mtry = 2, ntree = 500)
?randomForest
classifier <- train(y[train_points] ~ ., y = y, data = X[train_points,], method = "rf", mtry = VPS, ntree = 25, maxnodes = MN, nodesize = LP, replace = FALSE, sampsize = floor(0.632 * nrow(train_points)))
# Project to a meter-based CRS
df_proj <- spTransform(df, CRS('+init=epsg:3857'))
# Create buffer in meters
df_proj$geometry_buffer <- rgeos::gBuffer(df_proj, width = buffer_size, byid = TRUE)
# Read in the grid search results from GEE
grid_search_results <- read.csv('output/20230315_arbuscular_mycorrhizal_richness_grid_search_results_spatialCV.csv')
# Read in the grid search results from GEE
grid_search_results <- read.csv('output/20230501_arbuscular_mycorrhizal_richness_grid_search_results.csv')
VPS <- as.numeric(str_extract(grid_search_results[rep, "cName"], "VPS\\d+"))
grid_search_results
VPS <- as.numeric(str_extract(grid_search_results[rep, "cName"], "VPS\\d+"))
grid_search_results[rep, "cName"]
str_extract(grid_search_results[rep, "cName"], "VPS\\d+")
VPS <- 10
LP <- 4
# Set hyperparameters
classifier <- randomForest(mtry = 10, ntree = 25, nodesize = 4, replace = FALSE, sampsize = floor(0.632 * nrow(df_proj)))
# Set hyperparameters
classifier <- randomForest(df %>% select(covariateList), mtry = 10, ntree = 25, nodesize = 4, replace = FALSE, sampsize = floor(0.632 * nrow(df_proj)))
df %>% select(covariateList)
library(rgdal)
library(caret)
library(sp)
library(sf)
library(raster)
library(randomForest)
library(rgeos)
library(doParallel)
library(plyr)
library(tidyverse)
# Constants
# Constants
classProperty <- 'arbuscular_mycorrhizal_richness'
df <- read.csv('data/arbuscular_mycorrhizal_richness_training_data.csv')
# Convert DataFrame to SpatialPointsDataFrame
coordinates(df) <- c('Pixel_Long', 'Pixel_Lat')
proj4string(df) <- CRS('+init=epsg:4326')
# Variables to include in the model
covariateList <- c(
'CGIAR_PET',
'CHELSA_BIO_Annual_Mean_Temperature',
'CHELSA_BIO_Annual_Precipitation',
'CHELSA_BIO_Max_Temperature_of_Warmest_Month',
'CHELSA_BIO_Precipitation_Seasonality',
'ConsensusLandCover_Human_Development_Percentage',
'EarthEnvTexture_CoOfVar_EVI',
'EarthEnvTexture_Correlation_EVI',
'EarthEnvTexture_Homogeneity_EVI',
'EarthEnvTopoMed_AspectCosine',
'EarthEnvTopoMed_AspectSine',
'EarthEnvTopoMed_Elevation',
'EarthEnvTopoMed_Slope',
'EarthEnvTopoMed_TopoPositionIndex',
'EsaCci_BurntAreasProbability',
'GHS_Population_Density',
'GlobBiomass_AboveGroundBiomass',
'MODIS_NPP',
'SG_Depth_to_bedrock',
'SG_Sand_Content_005cm',
'SG_SOC_Content_005cm',
'SG_Soil_pH_H2O_005cm'
)
project_vars <- c(
'sequencing_platform454Roche',
'sequencing_platformIllumina',
'sample_typerhizosphere_soil',
'sample_typesoil',
'sample_typetopsoil',
'primersAML1_AML2_then_AMV4_5NF_AMDGR',
'primersAML1_AML2_then_NS31_AM1',
'primersAML1_AML2_then_nu_SSU_0595_5__nu_SSU_0948_3_',
'primersAMV4_5F_AMDGR',
'primersAMV4_5NF_AMDGR',
'primersGeoA2_AML2_then_NS31_AMDGR',
'primersGeoA2_NS4_then_NS31_AML2',
'primersGlomerWT0_Glomer1536_then_NS31_AM1A_and_GlomerWT0_Glomer1536_then_NS31_AM1B',
'primersGlomerWT0_Glomer1536_then_NS31_AM1A__GlomerWT0_Glomer1536_then_NS31_AM1B',
'primersNS1_NS4_then_AML1_AML2',
'primersNS1_NS4_then_AMV4_5NF_AMDGR',
'primersNS1_NS4_then_NS31_AM1',
'primersNS1_NS41_then_AML1_AML2',
'primersNS31_AM1',
'primersNS31_AML2',
'primersWANDA_AML2'
)
# Create final list of covariates
covariateList <- c(covariateList, project_vars)
buffer_size=1000
buffer_size=10000
buffer_size=100000
rep = 1
# Project to a meter-based CRS
df_proj <- spTransform(df, CRS('+init=epsg:3857'))
# Create buffer in meters
df_proj$geometry_buffer <- rgeos::gBuffer(df_proj, width = buffer_size, byid = TRUE)
# Set hyperparameters
classifier <- randomForest(df %>% select(covariateList), mtry = 10, ntree = 25, nodesize = 4, replace = FALSE, sampsize = floor(0.632 * nrow(df_proj)))
# Prepare data
set.seed(rep)
# Set hyperparameters
classifier <- randomForest(df %>% dplyr::select(covariateList), mtry = 10, ntree = 25, nodesize = 4, replace = FALSE, sampsize = floor(0.632 * nrow(df_proj)))
df <- read.csv('data/arbuscular_mycorrhizal_richness_training_data.csv')
# Convert DataFrame to SpatialPointsDataFrame
coordinates(df) <- c('Pixel_Long', 'Pixel_Lat')
proj4string(df) <- CRS('+init=epsg:4326')
df[covariateList]
# Set hyperparameters
classifier <- randomForest(df, mtry = 10, ntree = 25, nodesize = 4, replace = FALSE, sampsize = floor(0.632 * nrow(df_proj)))
# Create buffer in meters
df_proj$geometry_buffer <- rgeos::gBuffer(df_proj, width = buffer_size, byid = TRUE)
# Set hyperparameters
classifier <- randomForest(df, mtry = 10, ntree = 25, nodesize = 4, replace = FALSE, sampsize = floor(0.632 * nrow(df_proj)))
df <- read.csv('data/arbuscular_mycorrhizal_richness_training_data.csv')
# Set hyperparameters
classifier <- randomForest(df, mtry = 10, ntree = 25, nodesize = 4, replace = FALSE, sampsize = floor(0.632 * nrow(df_proj)))
library(rgdal)
library(caret)
library(sp)
library(sf)
library(raster)
library(randomForest)
library(rgeos)
library(doParallel)
library(plyr)
library(tidyverse)
# Constants
classProperty <- 'arbuscular_mycorrhizal_richness'
df <- read.csv('data/arbuscular_mycorrhizal_richness_training_data.csv')
# Convert DataFrame to SpatialPointsDataFrame
coordinates(df_sp) <- c('Pixel_Long', 'Pixel_Lat')
proj4string(df_sp) <- CRS('+init=epsg:4326')
# Variables to include in the model
covariateList <- c(
'CGIAR_PET',
'CHELSA_BIO_Annual_Mean_Temperature',
'CHELSA_BIO_Annual_Precipitation',
'CHELSA_BIO_Max_Temperature_of_Warmest_Month',
'CHELSA_BIO_Precipitation_Seasonality',
'ConsensusLandCover_Human_Development_Percentage',
'EarthEnvTexture_CoOfVar_EVI',
'EarthEnvTexture_Correlation_EVI',
'EarthEnvTexture_Homogeneity_EVI',
'EarthEnvTopoMed_AspectCosine',
'EarthEnvTopoMed_AspectSine',
'EarthEnvTopoMed_Elevation',
'EarthEnvTopoMed_Slope',
'EarthEnvTopoMed_TopoPositionIndex',
'EsaCci_BurntAreasProbability',
'GHS_Population_Density',
'GlobBiomass_AboveGroundBiomass',
'MODIS_NPP',
'SG_Depth_to_bedrock',
'SG_Sand_Content_005cm',
'SG_SOC_Content_005cm',
'SG_Soil_pH_H2O_005cm'
)
run_spatial_loo_cv <- function(buffer_size, rep) {
# Project to a meter-based CRS
df_proj <- spTransform(df, CRS('+init=epsg:3857'))
# Create buffer in meters
df_proj$geometry_buffer <- rgeos::gBuffer(df_proj, width = buffer_size, byid = TRUE)
# Set hyperparameters
classifier <- randomForest(df, mtry = 10, ntree = 25, nodesize = 4, replace = FALSE, sampsize = floor(0.632 * nrow(df_proj)))
# Prepare data
set.seed(rep)
sampled_df_proj <- df_proj[sample(nrow(df_proj), 10000, replace = FALSE),]
X <- sampled_df_proj[, covariateList, drop = FALSE]
y <- sampled_df_proj[, classProperty, drop = FALSE]
# Create LeaveOneOut folds after defining y
loo <- createFolds(y, k = nrow(df_proj), list = TRUE, returnTrain = FALSE)
predictions <- c()
# Perform spatial Leave-One-Out Cross-Validation
for (i in 1:length(loo)) {
test_point <- df_proj$geometry_buffer[loo[[i]]$indexOut]
train_points <- df_proj[!gIntersects(test_point, df_proj, byid = TRUE),]
if (nrow(train_points) > 0) {
classifier <- train(y[train_points] ~ ., y = y, data = X[train_points,], method = "rf", mtry = VPS, ntree = 25, maxnodes = MN, nodesize = LP, replace = FALSE, sampsize = floor(0.632 * nrow(train_points)))
predictions <- c(predictions, predict(classifier, X[-train_points,]))
} else {
predictions <- c(predictions, NA)
}
}
# Calculate R-squared value
r2 <- R2(predictions, y)
output <- data.frame(r2 = r2, rep = rep, buffer_size = buffer_size)
return(output)
}
# Project to a meter-based CRS
df_proj <- spTransform(df_sp, CRS('+init=epsg:3857'))
# Convert DataFrame to SpatialPointsDataFrame
coordinates(df_sp) <- df <- c('Pixel_Long', 'Pixel_Lat')
df_sp <- df
# Convert DataFrame to SpatialPointsDataFrame
coordinates(df_sp) <- c('Pixel_Long', 'Pixel_Lat')
library(rgdal)
library(caret)
library(sp)
library(sf)
library(raster)
library(randomForest)
library(rgeos)
library(doParallel)
library(plyr)
library(tidyverse)
# Constants
classProperty <- 'arbuscular_mycorrhizal_richness'
df <- read.csv('data/arbuscular_mycorrhizal_richness_training_data.csv')
df_sp <- df
# Convert DataFrame to SpatialPointsDataFrame
coordinates(df_sp) <- c('Pixel_Long', 'Pixel_Lat')
proj4string(df_sp) <- CRS('+init=epsg:4326')
# Variables to include in the model
covariateList <- c(
'CGIAR_PET',
'CHELSA_BIO_Annual_Mean_Temperature',
'CHELSA_BIO_Annual_Precipitation',
'CHELSA_BIO_Max_Temperature_of_Warmest_Month',
'CHELSA_BIO_Precipitation_Seasonality',
'ConsensusLandCover_Human_Development_Percentage',
'EarthEnvTexture_CoOfVar_EVI',
'EarthEnvTexture_Correlation_EVI',
'EarthEnvTexture_Homogeneity_EVI',
'EarthEnvTopoMed_AspectCosine',
'EarthEnvTopoMed_AspectSine',
'EarthEnvTopoMed_Elevation',
'EarthEnvTopoMed_Slope',
'EarthEnvTopoMed_TopoPositionIndex',
'EsaCci_BurntAreasProbability',
'GHS_Population_Density',
'GlobBiomass_AboveGroundBiomass',
'MODIS_NPP',
'SG_Depth_to_bedrock',
'SG_Sand_Content_005cm',
'SG_SOC_Content_005cm',
'SG_Soil_pH_H2O_005cm'
)
run_spatial_loo_cv <- function(buffer_size, rep) {
# Project to a meter-based CRS
df_proj <- spTransform(df_sp, CRS('+init=epsg:3857'))
# Create buffer in meters
df_proj$geometry_buffer <- rgeos::gBuffer(df_proj, width = buffer_size, byid = TRUE)
# Set hyperparameters
classifier <- randomForest(df, mtry = 10, ntree = 25, nodesize = 4, replace = FALSE, sampsize = floor(0.632 * nrow(df_proj)))
# Prepare data
set.seed(rep)
sampled_df_proj <- df_proj[sample(nrow(df_proj), 10000, replace = FALSE),]
X <- sampled_df_proj[, covariateList, drop = FALSE]
y <- sampled_df_proj[, classProperty, drop = FALSE]
# Create LeaveOneOut folds after defining y
loo <- createFolds(y, k = nrow(df_proj), list = TRUE, returnTrain = FALSE)
predictions <- c()
# Perform spatial Leave-One-Out Cross-Validation
for (i in 1:length(loo)) {
test_point <- df_proj$geometry_buffer[loo[[i]]$indexOut]
train_points <- df_proj[!gIntersects(test_point, df_proj, byid = TRUE),]
if (nrow(train_points) > 0) {
classifier <- train(y[train_points] ~ ., y = y, data = X[train_points,], method = "rf", mtry = VPS, ntree = 25, maxnodes = MN, nodesize = LP, replace = FALSE, sampsize = floor(0.632 * nrow(train_points)))
predictions <- c(predictions, predict(classifier, X[-train_points,]))
} else {
predictions <- c(predictions, NA)
}
}
# Calculate R-squared value
r2 <- R2(predictions, y)
output <- data.frame(r2 = r2, rep = rep, buffer_size = buffer_size)
return(output)
}
# Project to a meter-based CRS
df_proj <- spTransform(df_sp, CRS('+init=epsg:3857'))
# Create buffer in meters
df_proj$geometry_buffer <- rgeos::gBuffer(df_proj, width = buffer_size, byid = TRUE)
# Set hyperparameters
classifier <- randomForest(df %>% select(all_of(covariateList), all_of(classProperty)), mtry = 10, ntree = 25, nodesize = 4, replace = FALSE, sampsize = floor(0.632 * nrow(df_proj)))
classifier
# Prepare data
set.seed(rep)
sampled_df_proj <- df_proj[sample(nrow(df_proj), 10000, replace = FALSE),]
# sampled_df_proj <- df_proj[sample(nrow(df_proj), 10000, replace = FALSE),]
X <- df_proj[, covariateList, drop = FALSE]
y <- df_proj[, classProperty, drop = FALSE]
# Create LeaveOneOut folds after defining y
loo <- createFolds(y, k = nrow(df_proj), list = TRUE, returnTrain = FALSE)
predictions <- c()
# Perform spatial Leave-One-Out Cross-Validation
for (i in 1:length(loo)) {
test_point <- df_proj$geometry_buffer[loo[[i]]$indexOut]
train_points <- df_proj[!gIntersects(test_point, df_proj, byid = TRUE),]
if (nrow(train_points) > 0) {
classifier <- train(y[train_points] ~ ., y = y, data = X[train_points,], method = "rf", mtry = VPS, ntree = 25, maxnodes = MN, nodesize = LP, replace = FALSE, sampsize = floor(0.632 * nrow(train_points)))
predictions <- c(predictions, predict(classifier, X[-train_points,]))
} else {
predictions <- c(predictions, NA)
}
}
loo
loo = 1
test_point <- df_proj$geometry_buffer[loo[[i]]$indexOut]
df_proj
df_proj$geometry_buffer
run_spatial_loo_cv <- function(buffer_size, rep) {
# Project to a meter-based CRS
df_proj <- spTransform(df_sp, CRS('+init=epsg:3857'))
# Create buffer in meters
df_proj$geometry_buffer <- rgeos::gBuffer(df_proj, width = buffer_size, byid = TRUE)
# Set hyperparameters
classifier <- randomForest(df %>% select(all_of(covariateList), all_of(classProperty)), mtry = 10, ntree = 25, nodesize = 4, replace = FALSE, sampsize = floor(0.632 * nrow(df_proj)))
# Prepare data
set.seed(rep)
# sampled_df_proj <- df_proj[sample(nrow(df_proj), 10000, replace = FALSE),]
X <- df_proj[, covariateList, drop = FALSE]
y <- df_proj[, classProperty, drop = FALSE]
# Create LeaveOneOut folds after defining y
loo <- createFolds(y, k = nrow(df_proj), list = TRUE, returnTrain = FALSE)
predictions <- c()
# Perform spatial Leave-One-Out Cross-Validation
for (i in 1:length(loo)) {
test_point <- df_proj$geometry_buffer[loo[[i]]$indexOut]
train_points <- df_proj[!gIntersects(test_point, df_proj, byid = TRUE),]
if (nrow(train_points) > 0) {
classifier <- train(y[train_points] ~ ., y = y, data = X[train_points,], method = "rf", mtry = VPS, ntree = 25, maxnodes = MN, nodesize = LP, replace = FALSE, sampsize = floor(0.632 * nrow(train_points)))
predictions <- c(predictions, predict(classifier, X[-train_points,]))
} else {
predictions <- c(predictions, NA)
}
}
# Calculate R-squared value
r2 <- R2(predictions, y)
output <- data.frame(r2 = r2, rep = rep, buffer_size = buffer_size)
return(output)
}
buffer_sizes <- c(1000, 2500, 5000, 10000, 50000, 100000, 250000, 500000, 750000, 1000000)
reps <- seq(0, 9)
# Define the list of buffer sizes to use
buffer_sizes <- c(10000, 250000, 1000000)
reps <- seq(0, 2)
# Use parallel processing
registerDoParallel(cores = 7)
results <- foreach(buffer = buffer_sizes, rep = reps, .combine = rbind) %dopar% run_spatial_loo_cv(buffer, rep)
